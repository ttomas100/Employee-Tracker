"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cellText = exports.createHeaderAsRow = exports.renderTableHorizontalBorders = exports.findMaxLenOfColumn = exports.createRow = exports.createColum = exports.createTableHorizontalBorders = exports.textWithPadding = exports.convertRawRowOptionsToStandard = void 0;
const console_utils_1 = __importDefault(require("./console-utils"));
function convertRawRowOptionsToStandard(options) {
    if (options) {
        return {
            color: options.color,
        };
    }
    return undefined;
}
exports.convertRawRowOptionsToStandard = convertRawRowOptionsToStandard;
function textWithPadding(text, alignment, mxColumnLen) {
    const curTextSize = console_utils_1.default(text);
    // alignments for center padding case
    const leftPadding = Math.floor((mxColumnLen - curTextSize) / 2);
    const rightPadding = mxColumnLen - leftPadding - curTextSize;
    switch (alignment) {
        case 'left':
            return text.concat(' '.repeat(mxColumnLen - curTextSize));
        case 'center':
            return ' '
                .repeat(leftPadding)
                .concat(text)
                .concat(' '.repeat(rightPadding));
        case 'right':
        default:
            return ' '.repeat(mxColumnLen - curTextSize).concat(text);
    }
}
exports.textWithPadding = textWithPadding;
function createTableHorizontalBorders({ left, mid, right, other, }, column_lengths) {
    // ╚
    let ret = left;
    // ╚═══════╩═══════════════════════════════════════╩════════╩
    column_lengths.forEach((len) => {
        ret += other.repeat(len + 2);
        ret += mid;
    });
    // ╚═══════╩═══════════════════════════════════════╩════════
    ret = ret.slice(0, -mid.length);
    // ╚═══════╩═══════════════════════════════════════╩════════╝
    ret += right;
    return ret;
}
exports.createTableHorizontalBorders = createTableHorizontalBorders;
function createColum(name) {
    return { name, title: name };
}
exports.createColum = createColum;
function createRow(color, text) {
    return { color, text };
}
exports.createRow = createRow;
function findMaxLenOfColumn(column, rows) {
    const columnTitle = column.title;
    const columnId = column.name;
    let maxLen = console_utils_1.default(`${columnTitle}`);
    rows.forEach((row) => {
        maxLen = Math.max(maxLen, console_utils_1.default(`${row.text[columnId] || ''}`));
    });
    return maxLen;
}
exports.findMaxLenOfColumn = findMaxLenOfColumn;
function renderTableHorizontalBorders(style, column_lengths) {
    const str = createTableHorizontalBorders(style, column_lengths);
    return str;
}
exports.renderTableHorizontalBorders = renderTableHorizontalBorders;
function createHeaderAsRow(createRowFn, columns) {
    const headerColor = 'white_bold';
    const row = createRowFn(headerColor, {});
    columns.forEach((column) => {
        row.text[column.name] = column.title;
    });
    return row;
}
exports.createHeaderAsRow = createHeaderAsRow;
function cellText(text) {
    return text === undefined || text === null ? '' : text;
}
exports.cellText = cellText;
